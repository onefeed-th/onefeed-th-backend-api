// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: news.sql

package onefeed_th_sqlc

import (
	"context"
)

const getAllSource = `-- name: GetAllSource :many
SELECT DISTINCT source
FROM news
`

func (q *Queries) GetAllSource(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var source string
		if err := rows.Scan(&source); err != nil {
			return nil, err
		}
		items = append(items, source)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNews = `-- name: ListNews :many
SELECT id, title, link, source, image_url, publish_date, fetched_at
FROM news
WHERE news.source = ANY($1::TEXT [])
ORDER BY publish_date DESC
LIMIT $3 OFFSET $2
`

type ListNewsParams struct {
	Sources    []string `json:"sources"`
	PageOffset int32    `json:"page_offset"`
	PageLimit  int32    `json:"page_limit"`
}

func (q *Queries) ListNews(ctx context.Context, arg ListNewsParams) ([]News, error) {
	rows, err := q.db.Query(ctx, listNews, arg.Sources, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []News
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Link,
			&i.Source,
			&i.ImageUrl,
			&i.PublishDate,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeNewsByPublishedDate = `-- name: RemoveNewsByPublishedDate :exec
DELETE FROM news
WHERE publish_date < NOW() - INTERVAL '30 days'
`

func (q *Queries) RemoveNewsByPublishedDate(ctx context.Context) error {
	_, err := q.db.Exec(ctx, removeNewsByPublishedDate)
	return err
}
